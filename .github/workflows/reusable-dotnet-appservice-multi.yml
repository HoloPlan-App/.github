# .github/workflows/reusable-dotnet-appservice-multi.yml
name: Reusable .NET ‚Üí Azure App Service (multi-region, multi-instance)

on:
  workflow_call:
    inputs:
      project_path:       { required: true, type: string }
      deployment_config:  { required: true, type: string }
      dotnet_version:     { required: false, type: string, default: '9.0.x' }
    secrets:
      AZURE_TENANT_ID:       { required: true }
      AZURE_SUBSCRIPTION_ID: { required: true }
      AZURE_CLIENT_ID:       { required: true }

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ github.token }}
          fetch-depth: 0
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ inputs.dotnet_version }}
      
      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
      
      - name: Restore
        run: dotnet restore "${{ inputs.project_path }}"
      
      - name: Update version in appsettings.json
        shell: bash
        run: |
          PROJECT_DIR=$(dirname "${{ inputs.project_path }}")
          APPSETTINGS_FILE="$PROJECT_DIR/appsettings.json"
          
          echo "üìù Updating version in $APPSETTINGS_FILE"
          
          CURRENT_DATE=$(date +"%y.%m.%d")
          
          if [ ! -f "$APPSETTINGS_FILE" ]; then
            echo "‚ùå appsettings.json not found"
            exit 1
          fi
          
          EXISTING_VERSION=$(jq -r '.Application.Version // empty' "$APPSETTINGS_FILE")
          echo "Current version: $EXISTING_VERSION"
          
          if [[ "$EXISTING_VERSION" == "$CURRENT_DATE"* ]]; then
            SUFFIX=$(echo "$EXISTING_VERSION" | sed "s/$CURRENT_DATE//")
            if [ -z "$SUFFIX" ]; then
              NEW_VERSION="${CURRENT_DATE}a"
            else
              NEXT_LETTER=$(echo "$SUFFIX" | tr 'a-y' 'b-z')
              if [ "$NEXT_LETTER" = "$SUFFIX" ]; then
                NEW_VERSION="${CURRENT_DATE}aa"
              else
                NEW_VERSION="${CURRENT_DATE}${NEXT_LETTER}"
              fi
            fi
          else
            NEW_VERSION="${CURRENT_DATE}a"
          fi
          
          echo "New version: $NEW_VERSION"
          
          jq --arg version "$NEW_VERSION" '.Application.Version = $version' "$APPSETTINGS_FILE" > temp.json && mv temp.json "$APPSETTINGS_FILE"
          
          echo "‚úÖ Updated version to $NEW_VERSION"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "appsettings_file=$APPSETTINGS_FILE" >> $GITHUB_OUTPUT
        id: version_update
      
      - name: Commit version update
        continue-on-error: true
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add "${{ steps.version_update.outputs.appsettings_file }}"
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Auto-update version to ${{ steps.version_update.outputs.new_version }} [skip ci]"
            git push
            echo "‚úÖ Committed and pushed version update"
          fi
      
      - name: Check project configuration
        run: |
          echo "üîç Checking project file..."
          cat "${{ inputs.project_path }}"
      
      - name: Build
        run: dotnet build "${{ inputs.project_path }}" -c Release --no-restore
      
      - name: Test (non-blocking)
        continue-on-error: true
        run: |
          if compgen -G "**/*Tests*.csproj" > /dev/null; then
            dotnet test -c Release --no-build
          else
            echo "No tests found"
          fi
      
      - name: Publish
        run: |
          mkdir -p out
          dotnet publish "${{ inputs.project_path }}" -c Release -o out
          
          echo "üîç Checking publish output:"
          test -d out/Pages && echo "‚úÖ Pages directory exists" || echo "‚ùå Pages directory missing"
          test -d out/wwwroot && echo "‚úÖ wwwroot directory exists" || echo "‚ùå wwwroot directory missing"
          echo "CSHTML files: $(find out/ -name '*.cshtml' 2>/dev/null | wc -l)"
          find out/ -name "appsettings*.json" 2>/dev/null || echo "No appsettings found"
      
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          tenant-id:       ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          client-id:       ${{ secrets.AZURE_CLIENT_ID }}
      
      - name: Prepare deployment package
        shell: bash
        run: |
          cd out
          
          echo "üì¶ Creating deployment package..."
          test -d Pages && echo "‚úÖ Pages in package" || echo "‚ùå Pages missing"
          test -d wwwroot && echo "‚úÖ wwwroot in package" || echo "‚ùå wwwroot missing"
          
          # Remove _logs if it exists (shouldn't be there but just in case)
          if [ -d "_logs" ]; then
            echo "‚ö†Ô∏è Removing _logs directory from publish output"
            rm -rf _logs
          fi
          
          # Create ZIP
          zip -r ../deployment.zip .
          cd ..
          
          echo "‚úÖ Created deployment.zip ($(du -h deployment.zip | cut -f1))"
      
      - name: Deploy to multiple regions and instances
        shell: bash
        run: |
          echo "Deployment configuration: ${{ inputs.deployment_config }}"
          
          echo '${{ inputs.deployment_config }}' | jq -c '.[]' | while read region; do
            RESOURCE_GROUP=$(echo $region | jq -r '.rg')
            WEBAPPS_CSV=$(echo $region | jq -r '.apps')
            
            echo "üåç Deploying to region: $RESOURCE_GROUP"
            
            IFS=';' read -ra APPS <<< "$WEBAPPS_CSV"
            for APP in "${APPS[@]}"; do
              echo "  üì¶ Deploying to $APP..."
              
              # Stop the app first to release file locks
              echo "  ‚è∏Ô∏è Stopping $APP to release file locks..."
              az webapp stop --name "$APP" --resource-group "$RESOURCE_GROUP"
              
              # Use az webapp deploy with clean flag
              echo "  üì¶ Deploying (this may take a few minutes)..."
              az webapp deploy \
                --resource-group "$RESOURCE_GROUP" \
                --name "$APP" \
                --src-path "./deployment.zip" \
                --type zip \
                --clean true \
                --restart true \
                --async false \
                --timeout 1200
              
              DEPLOY_RESULT=$?
              
              if [ $DEPLOY_RESULT -eq 0 ]; then
                echo "  ‚úÖ Deployed to $APP"
                
                # Ensure app is started
                echo "  ‚ñ∂Ô∏è Ensuring $APP is running..."
                az webapp start --name "$APP" --resource-group "$RESOURCE_GROUP"
                echo "  ‚úÖ App is running"
              else
                echo "  ‚ö†Ô∏è Deployment command failed or timed out"
                echo "  üîç Checking deployment status via Kudu API..."
                
                # Check if deployment actually succeeded via Kudu
                sleep 10
                KUDU_STATUS=$(curl -s "https://$APP.scm.azurewebsites.net/api/deployments/latest" | jq -r '.status // "unknown"')
                echo "  Kudu deployment status: $KUDU_STATUS"
                
                # Start the app regardless
                echo "  ‚ñ∂Ô∏è Starting $APP..."
                az webapp start --name "$APP" --resource-group "$RESOURCE_GROUP"
                
                if [ "$KUDU_STATUS" = "4" ] || [ "$KUDU_STATUS" = "Success" ]; then
                  echo "  ‚úÖ Deployment actually succeeded (timeout was false alarm)"
                else
                  echo "  ‚ùå Deployment genuinely failed"
                  exit 1
                fi
              fi
            done
            
            echo "‚úÖ Completed deployment to $RESOURCE_GROUP"
          done
          
          echo "üéâ All deployments completed!"
      
      - name: Create GitHub Deployment Records
        if: success()
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üìù Creating GitHub deployment records..."
          
          echo '${{ inputs.deployment_config }}' | jq -c '.[]' | while read region; do
            RESOURCE_GROUP=$(echo $region | jq -r '.rg')
            WEBAPPS_CSV=$(echo $region | jq -r '.apps')
            
            IFS=';' read -ra APPS <<< "$WEBAPPS_CSV"
            for APP in "${APPS[@]}"; do
              # Determine environment name based on resource group
              if [[ "$RESOURCE_GROUP" == *"dev"* ]]; then
                ENV_NAME="Dev"
              elif [[ "$RESOURCE_GROUP" == *"prod"* ]] || [[ "$RESOURCE_GROUP" == "MDU" ]]; then
                ENV_NAME="Prod"
              else
                ENV_NAME="$RESOURCE_GROUP"
              fi
              
              echo "  üìù Creating deployment record for $APP in $ENV_NAME..."
              
              # Create deployment
              DEPLOYMENT_ID=$(gh api \
                --method POST \
                -H "Accept: application/vnd.github+json" \
                /repos/${{ github.repository }}/deployments \
                -f ref='${{ github.ref }}' \
                -f environment="$ENV_NAME" \
                -f description="Deploy to $APP" \
                -f auto_merge=false \
                -f required_contexts='[]' \
                --jq '.id')
              
              if [ -n "$DEPLOYMENT_ID" ]; then
                echo "  ‚úÖ Created deployment $DEPLOYMENT_ID"
                
                # Mark deployment as successful
                gh api \
                  --method POST \
                  -H "Accept: application/vnd.github+json" \
                  /repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses \
                  -f state='success' \
                  -f environment="$ENV_NAME" \
                  -f description="Successfully deployed to $APP" \
                  -f log_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                
                echo "  ‚úÖ Marked deployment as successful"
              else
                echo "  ‚ö†Ô∏è Failed to create deployment record"
              fi
            done
          done
