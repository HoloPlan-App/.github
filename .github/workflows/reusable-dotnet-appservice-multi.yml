# .github/workflows/reusable-dotnet-appservice-multi.yml
name: Reusable .NET ‚Üí Azure App Service (multi-region, multi-instance)

on:
  workflow_call:
    inputs:
      project_path:       { required: true, type: string }
      deployment_config:  { required: true, type: string }
      dotnet_version:     { required: false, type: string, default: '9.0.x' }
    secrets:
      AZURE_TENANT_ID:       { required: true }
      AZURE_SUBSCRIPTION_ID: { required: true }
      AZURE_CLIENT_ID:       { required: true }

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ github.token }}
          fetch-depth: 0
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ inputs.dotnet_version }}
      
      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
      
      - name: Restore
        run: dotnet restore "${{ inputs.project_path }}"
      
      - name: Update version in appsettings.json
        shell: bash
        run: |
          PROJECT_DIR=$(dirname "${{ inputs.project_path }}")
          APPSETTINGS_FILE="$PROJECT_DIR/appsettings.json"
          
          echo "üìù Updating version in $APPSETTINGS_FILE"
          
          CURRENT_DATE=$(date +"%y.%m.%d")
          
          if [ ! -f "$APPSETTINGS_FILE" ]; then
            echo "‚ùå appsettings.json not found"
            exit 1
          fi
          
          EXISTING_VERSION=$(jq -r '.Application.Version // empty' "$APPSETTINGS_FILE")
          echo "Current version: $EXISTING_VERSION"
          
          if [[ "$EXISTING_VERSION" == "$CURRENT_DATE"* ]]; then
            SUFFIX=$(echo "$EXISTING_VERSION" | sed "s/$CURRENT_DATE//")
            if [ -z "$SUFFIX" ]; then
              NEW_VERSION="${CURRENT_DATE}a"
            else
              NEXT_LETTER=$(echo "$SUFFIX" | tr 'a-y' 'b-z')
              if [ "$NEXT_LETTER" = "$SUFFIX" ]; then
                NEW_VERSION="${CURRENT_DATE}aa"
              else
                NEW_VERSION="${CURRENT_DATE}${NEXT_LETTER}"
              fi
            fi
          else
            NEW_VERSION="${CURRENT_DATE}a"
          fi
          
          echo "New version: $NEW_VERSION"
          
          jq --arg version "$NEW_VERSION" '.Application.Version = $version' "$APPSETTINGS_FILE" > temp.json && mv temp.json "$APPSETTINGS_FILE"
          
          echo "‚úÖ Updated version to $NEW_VERSION"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "appsettings_file=$APPSETTINGS_FILE" >> $GITHUB_OUTPUT
        id: version_update
      
      - name: Commit version update
        continue-on-error: true
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add "${{ steps.version_update.outputs.appsettings_file }}"
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Auto-update version to ${{ steps.version_update.outputs.new_version }} [skip ci]"
            git push
            echo "‚úÖ Committed and pushed version update"
          fi
      
      - name: Check project configuration
        run: |
          echo "üîç Checking project file..."
          cat "${{ inputs.project_path }}"
      
      - name: Build
        run: dotnet build "${{ inputs.project_path }}" -c Release --no-restore
      
      - name: Test (non-blocking)
        continue-on-error: true
        run: |
          if compgen -G "**/*Tests*.csproj" > /dev/null; then
            dotnet test -c Release --no-build
          else
            echo "No tests found"
          fi
      
      - name: Publish
        run: |
          mkdir -p out
          dotnet publish "${{ inputs.project_path }}" -c Release -o out
          
          echo "üîç Checking publish output:"
          test -d out/Pages && echo "‚úÖ Pages directory exists" || echo "‚ùå Pages directory missing"
          test -d out/wwwroot && echo "‚úÖ wwwroot directory exists" || echo "‚ùå wwwroot directory missing"
          echo "CSHTML files: $(find out/ -name '*.cshtml' 2>/dev/null | wc -l)"
          find out/ -name "appsettings*.json" 2>/dev/null || echo "No appsettings found"
      
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          tenant-id:       ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          client-id:       ${{ secrets.AZURE_CLIENT_ID }}
      
      - name: Deploy to multiple regions and instances
        shell: bash
        run: |
          echo "Deployment configuration: ${{ inputs.deployment_config }}"
          
          cd out
          
          echo "üì¶ Creating deployment package..."
          test -d Pages && echo "‚úÖ Pages in package" || echo "‚ùå Pages missing"
          test -d wwwroot && echo "‚úÖ wwwroot in package" || echo "‚ùå wwwroot missing"
          
          zip -r ../deployment.zip .
          cd ..
          
          echo "‚úÖ Created deployment.zip ($(du -h deployment.zip | cut -f1))"
          
          echo '${{ inputs.deployment_config }}' | jq -c '.[]' | while read region; do
            RESOURCE_GROUP=$(echo $region | jq -r '.rg')
            WEBAPPS_CSV=$(echo $region | jq -r '.apps')
            
            echo "üåç Deploying to region: $RESOURCE_GROUP"
            
            IFS=';' read -ra APPS <<< "$WEBAPPS_CSV"
            for APP in "${APPS[@]}"; do
              echo "  üì¶ Deploying to $APP..."
              
              # Use az webapp deploy with clean flag to ensure proper deployment
              az webapp deploy \
                --resource-group "$RESOURCE_GROUP" \
                --name "$APP" \
                --src-path "./deployment.zip" \
                --type zip \
                --clean true \
                --restart true \
                --async false
              
              if [ $? -eq 0 ]; then
                echo "  ‚úÖ Deployed to $APP"
              else
                echo "  ‚ùå Failed to deploy to $APP"
                exit 1
              fi
            done
            
            echo "‚úÖ Completed deployment to $RESOURCE_GROUP"
          done
          
          echo "üéâ All deployments completed!"
