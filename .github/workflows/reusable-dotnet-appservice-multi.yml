# .github/workflows/reusable-dotnet-appservice-multi.yml
name: Reusable .NET ‚Üí Azure App Service (multi-region, multi-instance)

on:
  workflow_call:
    inputs:
      project_path:       { required: true, type: string }  # e.g., MDUPortal/MDUPortal.csproj
      deployment_config:  { required: true, type: string }  # JSON: [{"rg":"rg-uk","apps":"app1;app2"},{"rg":"rg-de","apps":"app3;app4"}]
      dotnet_version:     { required: false, type: string, default: '9.0.x' }
    secrets:
      AZURE_TENANT_ID:       { required: true }
      AZURE_SUBSCRIPTION_ID: { required: true }
      AZURE_CLIENT_ID:       { required: true }

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ inputs.dotnet_version }}
      
      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
      
      - name: Restore
        run: dotnet restore "${{ inputs.project_path }}"
      
      - name: Update version in appsettings.json
        shell: bash
        run: |
          # Extract project directory from project path
          PROJECT_DIR=$(dirname "${{ inputs.project_path }}")
          APPSETTINGS_FILE="$PROJECT_DIR/appsettings.json"
          
          echo "üìù Updating version in $APPSETTINGS_FILE"
          
          # Generate version using date format YY.MM.DDx
          CURRENT_DATE=$(date +"%y.%m.%d")
          
          # Check if appsettings.json exists
          if [ ! -f "$APPSETTINGS_FILE" ]; then
            echo "‚ùå appsettings.json not found at $APPSETTINGS_FILE"
            exit 1
          fi
          
          # Check if there's already a version for today
          EXISTING_VERSION=$(jq -r '.Version // empty' "$APPSETTINGS_FILE")
          echo "Current version: $EXISTING_VERSION"
          
          if [[ "$EXISTING_VERSION" == "$CURRENT_DATE"* ]]; then
            # Extract the letter suffix (a, b, c, etc.)
            SUFFIX=$(echo "$EXISTING_VERSION" | sed "s/$CURRENT_DATE//")
            if [ -z "$SUFFIX" ]; then
              NEW_VERSION="${CURRENT_DATE}a"
            else
              # Increment the letter (a->b, b->c, etc.)
              NEXT_LETTER=$(echo "$SUFFIX" | tr 'a-y' 'b-z')
              if [ "$NEXT_LETTER" = "$SUFFIX" ]; then
                # If we're at 'z', go to 'aa'
                NEW_VERSION="${CURRENT_DATE}aa"
              else
                NEW_VERSION="${CURRENT_DATE}${NEXT_LETTER}"
              fi
            fi
          else
            # First version of the day
            NEW_VERSION="${CURRENT_DATE}a"
          fi
          
          echo "New version: $NEW_VERSION"
          
          # Update the version in appsettings.json
          jq --arg version "$NEW_VERSION" '.Version = $version' "$APPSETTINGS_FILE" > temp.json && mv temp.json "$APPSETTINGS_FILE"
          
          echo "‚úÖ Updated version to $NEW_VERSION"
          echo "üìÑ Updated appsettings.json:"
          jq '.Version' "$APPSETTINGS_FILE"
      
      - name: Build
        run: dotnet build "${{ inputs.project_path }}" -c Release --no-restore
      
      # Non-blocking tests now; make blocking later by removing 'continue-on-error'
      - name: Test (non-blocking until tests exist)
        continue-on-error: true
        run: |
          if ls **/*Tests*.csproj 1> /dev/null 2>&1; then
            dotnet test -c Release --no-build
          else
            echo "No tests yet. Add tests and make this step required later."
          fi
      
      - name: Publish
        run: |
          mkdir -p out
          dotnet publish "${{ inputs.project_path }}" -c Release -o out
          echo "üìÅ Contents of out directory:"
          ls -la out/
          echo "üìÅ Current working directory:"
          pwd
          echo "üìÅ GITHUB_WORKSPACE contents:"
          ls -la $GITHUB_WORKSPACE/
      
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          tenant-id:       ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          client-id:       ${{ secrets.AZURE_CLIENT_ID }}
      
      - name: Debug before deployment
        run: |
          echo "üìÅ Checking paths before deployment:"
          echo "Current directory: $(pwd)"
          echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
          echo "Contents of current directory:"
          ls -la
          echo "Contents of out directory:"
          ls -la out/ || echo "out directory not found"
          echo "Contents of GITHUB_WORKSPACE/out:"
          ls -la $GITHUB_WORKSPACE/out/ || echo "GITHUB_WORKSPACE/out not found"     
      - name: Deploy to multiple regions and instances
        shell: bash
        run: |
          echo "Deployment configuration: ${{ inputs.deployment_config }}"
          
          # Create ZIP file from out directory
          echo "üì¶ Creating deployment package..."
          cd out
          zip -r ../deployment.zip .
          cd ..
          echo "‚úÖ Created deployment.zip"
          ls -la deployment.zip
          
          # Parse JSON deployment config
          echo '${{ inputs.deployment_config }}' | jq -c '.[]' | while read region; do
            RESOURCE_GROUP=$(echo $region | jq -r '.rg')
            WEBAPPS_CSV=$(echo $region | jq -r '.apps')
            
            echo "üåç Deploying to region: $RESOURCE_GROUP"
            
            # Deploy to all apps in this resource group
            IFS=';' read -ra APPS <<< "$WEBAPPS_CSV"
            for APP in "${APPS[@]}"; do
              echo "  üì¶ Deploying to $APP in $RESOURCE_GROUP..."
              az webapp deploy \
                --resource-group "$RESOURCE_GROUP" \
                --name "$APP" \
                --src-path "./deployment.zip" \
                --type zip
              
              if [ $? -eq 0 ]; then
                echo "  ‚úÖ Successfully deployed to $APP"
              else
                echo "  ‚ùå Failed to deploy to $APP"
                exit 1
              fi
            done
            
            echo "‚úÖ Completed deployment to $RESOURCE_GROUP"
          done
          
          echo "üéâ All deployments completed successfully!"
