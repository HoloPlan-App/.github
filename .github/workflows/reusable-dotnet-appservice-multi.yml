# .github/workflows/reusable-dotnet-appservice-multi.yml
name: Reusable .NET ‚Üí Azure App Service (multi-region, multi-instance)

on:
  workflow_call:
    inputs:
      project_path:       { required: true, type: string }  # e.g., MDUPortal/MDUPortal.csproj
      deployment_config:  { required: true, type: string }  # JSON: [{"rg":"rg-uk","apps":"app1;app2"},{"rg":"rg-de","apps":"app3;app4"}]
      dotnet_version:     { required: false, type: string, default: '9.0.x' }
    secrets:
      AZURE_TENANT_ID:       { required: true }
      AZURE_SUBSCRIPTION_ID: { required: true }
      AZURE_CLIENT_ID:       { required: true }

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ github.token }}
          fetch-depth: 0  # Fetch full history for proper git operations
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ inputs.dotnet_version }}
      
      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
      
      - name: Restore
        run: dotnet restore "${{ inputs.project_path }}"
      
      - name: Update version in appsettings.json
        shell: bash
        run: |
          # Extract project directory from project path
          PROJECT_DIR=$(dirname "${{ inputs.project_path }}")
          APPSETTINGS_FILE="$PROJECT_DIR/appsettings.json"
          
          echo "üìù Updating version in $APPSETTINGS_FILE"
          
          # Generate version using date format YY.MM.DDx
          CURRENT_DATE=$(date +"%y.%m.%d")
          
          # Check if appsettings.json exists
          if [ ! -f "$APPSETTINGS_FILE" ]; then
            echo "‚ùå appsettings.json not found at $APPSETTINGS_FILE"
            exit 1
          fi
          
          # Check if there's already a version for today
          EXISTING_VERSION=$(jq -r '.Application.Version // empty' "$APPSETTINGS_FILE")
          echo "Current version: $EXISTING_VERSION"
          
          if [[ "$EXISTING_VERSION" == "$CURRENT_DATE"* ]]; then
            # Extract the letter suffix (a, b, c, etc.)
            SUFFIX=$(echo "$EXISTING_VERSION" | sed "s/$CURRENT_DATE//")
            if [ -z "$SUFFIX" ]; then
              NEW_VERSION="${CURRENT_DATE}a"
            else
              # Increment the letter (a->b, b->c, etc.)
              NEXT_LETTER=$(echo "$SUFFIX" | tr 'a-y' 'b-z')
              if [ "$NEXT_LETTER" = "$SUFFIX" ]; then
                # If we're at 'z', go to 'aa'
                NEW_VERSION="${CURRENT_DATE}aa"
              else
                NEW_VERSION="${CURRENT_DATE}${NEXT_LETTER}"
              fi
            fi
          else
            # First version of the day
            NEW_VERSION="${CURRENT_DATE}a"
          fi
          
          echo "New version: $NEW_VERSION"
          
          # Update the version in appsettings.json
          jq --arg version "$NEW_VERSION" '.Application.Version = $version' "$APPSETTINGS_FILE" > temp.json && mv temp.json "$APPSETTINGS_FILE"
          
          echo "‚úÖ Updated version to $NEW_VERSION"
          echo "üìÑ Updated appsettings.json:"
          jq '.Application.Version' "$APPSETTINGS_FILE"
          
          # Set the new version as an output for later steps
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "appsettings_file=$APPSETTINGS_FILE" >> $GITHUB_OUTPUT
        id: version_update
      
      - name: Commit version update
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add "${{ steps.version_update.outputs.appsettings_file }}"
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            # Pull latest changes to avoid conflicts
            echo "üîÑ Pulling latest changes before committing..."
            git fetch origin dev
            
            # Try to rebase first (cleaner history)
            if git rebase origin/dev; then
              echo "‚úÖ Successfully rebased"
            else
              echo "‚ö†Ô∏è Rebase failed, aborting and trying merge..."
              git rebase --abort
              git merge origin/dev --no-edit || {
                echo "‚ùå Merge failed, skipping version commit to avoid conflicts"
                git reset --hard HEAD
                exit 0
              }
            fi
            
            git commit -m "Auto-update version to ${{ steps.version_update.outputs.new_version }} [skip ci]"
            git push origin dev
            echo "‚úÖ Committed and pushed version update"
          fi
      
      - name: Check project configuration
        run: |
          echo "üîç Checking project file configuration..."
          PROJECT_FILE="${{ inputs.project_path }}"
          echo "Project file: $PROJECT_FILE"
          
          if [ -f "$PROJECT_FILE" ]; then
            echo "üìÑ Project file contents:"
            cat "$PROJECT_FILE"
            
            echo ""
            echo "üîç Checking for publish-related settings:"
            grep -i "publish\|content\|copytooutput\|embed" "$PROJECT_FILE" || echo "No publish-related settings found"
          else
            echo "‚ùå Project file not found: $PROJECT_FILE"
            exit 1
          fi
      
      # Non-blocking tests now; make blocking later by removing 'continue-on-error'
      - name: Test (non-blocking until tests exist)
        continue-on-error: true
        run: |
          if ls **/*Tests*.csproj 1> /dev/null 2>&1; then
            dotnet test -c Release --no-build
          else
            echo "No tests yet. Add tests and make this step required later."
          fi
      
      - name: Publish
        run: |
          mkdir -p out
          dotnet publish "${{ inputs.project_path }}" -c Release -o out
          echo "üìÅ Contents of out directory:"
          ls -la out/
          
          # Check for specific file types that should be there
          echo "ÔøΩ CheckBing for key file types in out/:"
          echo "Views (.cshtml files):"
          find out/ -name "*.cshtml" | head -10 || echo "No .cshtml files found"
          echo "Static files (wwwroot content):"
          find out/wwwroot -type f | head -10 2>/dev/null || echo "No wwwroot content found"
          echo "Configuration files:"
          find out/ -name "appsettings*.json" || echo "No appsettings files found"
          echo "Main executable:"
          find out/ -name "*.dll" | grep -E "(MDUPortal|$(basename '${{ inputs.project_path }}' .csproj))" || echo "Main DLL not found"
          
          echo "üìÅ Current working directory:"
          pwd
          echo "üìÅ GITHUB_WORKSPACE contents:"
          ls -la $GITHUB_WORKSPACE/
      
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          tenant-id:       ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          client-id:       ${{ secrets.AZURE_CLIENT_ID }}
      
      - name: Debug before deployment
        run: |
          echo "üìÅ Checking paths before deployment:"
          echo "Current directory: $(pwd)"
          echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
          echo "Contents of current directory:"
          ls -la
          echo "Contents of out directory:"
          ls -la out/ || echo "out directory not found"
          echo "Contents of GITHUB_WORKSPACE/out:"
          ls -la $GITHUB_WORKSPACE/out/ || echo "GITHUB_WORKSPACE/out not found"     
      - name: Deploy to multiple regions and instances
        shell: bash
        run: |
          echo "Deployment configuration: ${{ inputs.deployment_config }}"
          
          # Create ZIP file from out directory
          echo "üì¶ Creating deployment package..."
          cd out
          
          # List what's being packaged
          echo "üìã Files being packaged:"
          ls -laR | head -50
          
          # Check for key files
          echo "üîç Checking for key files:"
          ls -la *.dll 2>/dev/null | head -10 || echo "No DLL files found"
          ls -la appsettings*.json 2>/dev/null || echo "No appsettings files found"
          ls -la web.config 2>/dev/null || echo "No web.config found"
          
          zip -r ../deployment.zip .
          cd ..
          echo "‚úÖ Created deployment.zip"
          ls -lh deployment.zip
          
          # Show what's in the ZIP
          echo "üì¶ Contents of deployment.zip (first 30 files):"
          unzip -l deployment.zip | head -30
          
          # Parse JSON deployment config
          echo '${{ inputs.deployment_config }}' | jq -c '.[]' | while read region; do
            RESOURCE_GROUP=$(echo $region | jq -r '.rg')
            WEBAPPS_CSV=$(echo $region | jq -r '.apps')
            
            echo "üåç Deploying to region: $RESOURCE_GROUP"
            
            # Deploy to all apps in this resource group
            IFS=';' read -ra APPS <<< "$WEBAPPS_CSV"
            for APP in "${APPS[@]}"; do
              echo "  üì¶ Deploying to $APP in $RESOURCE_GROUP..."
              
              # Deploy the ZIP file
              az webapp deploy \
                --resource-group "$RESOURCE_GROUP" \
                --name "$APP" \
                --src-path "./deployment.zip" \
                --type zip \
                --async false
              
              if [ $? -eq 0 ]; then
                echo "  ‚úÖ Successfully deployed to $APP"
                
                # Force restart the app to ensure changes take effect
                echo "  üîÑ Restarting app to ensure changes take effect..."
                az webapp restart --name "$APP" --resource-group "$RESOURCE_GROUP"
                echo "  ‚úÖ App restarted"
                
              else
                echo "  ‚ùå Failed to deploy to $APP"
                exit 1
              fi
            done
            
            echo "‚úÖ Completed deployment to $RESOURCE_GROUP"
          done
          
          echo "üéâ All deployments completed successfully!"
          
          # Enhanced deployment verification and debugging
          echo "üîç Verifying deployment and debugging..."
          sleep 30  # Wait for deployment to propagate
          
          # Parse JSON again to verify each app
          echo '${{ inputs.deployment_config }}' | jq -c '.[]' | while read region; do
            RESOURCE_GROUP=$(echo $region | jq -r '.rg')
            WEBAPPS_CSV=$(echo $region | jq -r '.apps')
            
            IFS=';' read -ra APPS <<< "$WEBAPPS_CSV"
            for APP in "${APPS[@]}"; do
              echo "üåê Debugging deployment for $APP..."
              
              # Get app details
              APP_URL=$(az webapp show --name "$APP" --resource-group "$RESOURCE_GROUP" --query "defaultHostName" -o tsv)
              echo "App URL: https://$APP_URL"
              
              # Check deployment status
              echo "üìã Deployment status:"
              az webapp deployment list --name "$APP" --resource-group "$RESOURCE_GROUP" --query "[0].{status:status,active:active,message:message,received_time:received_time}" -o table
              
              # Check if there are multiple deployment slots
              echo "üé∞ Checking deployment slots:"
              az webapp deployment slot list --name "$APP" --resource-group "$RESOURCE_GROUP" -o table || echo "No additional slots found"
              
              # Check app settings for any deployment-related configs
              echo "‚öôÔ∏è Checking key app settings:"
              az webapp config appsettings list --name "$APP" --resource-group "$RESOURCE_GROUP" --query "[?contains(name, 'WEBSITE_') || contains(name, 'SCM_')].{name:name,value:value}" -o table
              
              # Check the site's response and headers
              echo "üåê Testing site response:"
              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$APP_URL" || echo "000")
              echo "HTTP Status: $HTTP_STATUS"
              
              # Get response headers to check for caching issues
              echo "üìÑ Response headers:"
              curl -s -I "https://$APP_URL" | head -10
              
              # Try to check if the version endpoint exists (if you have one)
              echo "üî¢ Checking for version info:"
              curl -s "https://$APP_URL/api/version" || echo "No version endpoint found"
              
              # Check the Kudu site (SCM) for deployment logs
              echo "üîß Checking Kudu deployment info:"
              KUDU_URL="https://$APP.scm.azurewebsites.net"
              echo "Kudu URL: $KUDU_URL"
              
              if [ "$HTTP_STATUS" = "200" ]; then
                echo "‚úÖ $APP is responding"
              else
                echo "‚ö†Ô∏è $APP returned status $HTTP_STATUS"
              fi
              
              echo "----------------------------------------"
            done
          done
